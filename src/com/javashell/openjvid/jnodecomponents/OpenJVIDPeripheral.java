package com.javashell.openjvid.jnodecomponents;

import java.awt.Dimension;
import java.awt.image.BufferedImage;
import java.io.IOException;
import java.net.InetSocketAddress;
import java.net.ServerSocket;
import java.net.Socket;
import java.nio.ByteBuffer;
import java.nio.channels.ServerSocketChannel;
import java.nio.channels.SocketChannel;
import java.util.UUID;

import com.javashell.openjvid.peripheral.PeripheralDescriptor;
import com.javashell.openjvid.peripheral.PeripheralDiscoveryService;
import com.javashell.video.VideoProcessor;
import com.javashell.video.egressors.QOYStreamEgressor;
import com.javashell.video.ingestors.QOYStreamIngestor;

public class OpenJVIDPeripheral implements VideoProcessor {
	private final ServerSocket serv;
	private Socket client;
	private final UUID sessionID;
	private QOYStreamEgressor egress;
	private QOYStreamIngestor ingest;
	private BufferedImage previousFrame, receivedFrame;
	private Thread decoderThread;

	// Used to start a peripheral negotation
	public OpenJVIDPeripheral(PeripheralDescriptor pd) throws IOException {
		serv = new ServerSocket();

		serv.bind(new InetSocketAddress(0));
		sessionID = UUID.randomUUID();
		client = PeripheralDiscoveryService.negotiatePeripheralCommunications(pd, serv, sessionID);
		egress = new QOYStreamEgressor();
	}

	// Used in response to a negotiation request, as the sessionID would have been
	// generated by the originator
	public OpenJVIDPeripheral(PeripheralDescriptor pd, UUID sessionID, int port) throws IOException {
		serv = null;
		this.sessionID = sessionID;
		
		client = new Socket();
		client.connect(new InetSocketAddress(pd.getInetAddress(), port));
		ingest = new QOYStreamIngestor();
		decoderThread = new Thread(new Runnable() {
			public void run() {
				int segmentNumber = 0;
				byte[][] imageBytes = new byte[12][];
				while (client.isConnected()) {
					try {
						final byte[] intBytes = client.getInputStream().readNBytes(4);
						final int bufSize = ByteBuffer.wrap(intBytes).getInt();

						final byte[] image = client.getInputStream().readNBytes(bufSize);

						imageBytes[segmentNumber] = image;
						segmentNumber++;

						if (segmentNumber == 12) {
							receivedFrame = ingest.convert(imageBytes, 1920, 1080, 12);
							segmentNumber = 0;
						}

					} catch (Exception e) {
						e.printStackTrace();
					}
				}
			}
		});
	}

	@Override
	public BufferedImage processFrame(BufferedImage frame) {
		// Piggy back on QOYV processing
		if (ingest == null) {
			final byte[][] imageBytes = egress.convertFromBufferedImage(frame, previousFrame, true, 12);
			try {
				for (int i = 0; i < imageBytes.length; i++) {
					client.getOutputStream().write(ByteBuffer.allocate(4).putInt(imageBytes[i].length).array());
					client.getOutputStream().write(imageBytes[i]);
				}
			} catch (Exception e) {
				e.printStackTrace();
			}
			previousFrame = frame;
			return frame;
		} else {
			System.out.println("FRAME");
			return receivedFrame;
		}
	}

	@Override
	public boolean open() {
		if (ingest != null) {
			decoderThread.setName("OpenJVID-PeripheralDecoder");
			decoderThread.start();
		}
		return true;
	}

	@Override
	public boolean close() {
		try {
			client.close();
			if (serv != null) {
				serv.close();
			}
			return true;
		} catch (Exception e) {
			return false;
		}
	}

	@Override
	public Dimension getResolution() {
		return null;
	}

}
